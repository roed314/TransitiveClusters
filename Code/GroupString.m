// Ported from FiniteGroups/Code/utils.m and lehmer.m

intrinsic DecodePerm(x::RngIntElt, n::RngIntElt) -> GrpPermElt
    {Given rank x, return corresponding permutation in Sym(n)}
    return LehmerCodeToPermutation(RankToLehmerCode(x,n));
end intrinsic;

intrinsic RankToLehmerCode(x::RngIntElt, n::RngIntElt) -> SeqEnum
  {Returns the Lehmer code for rank x}
  lehmer := [];
  for j in [1..n] do
    Append(~lehmer, x mod j);
    x := x div j;
  end for;
  Reverse(~lehmer);
  return lehmer;
end intrinsic;

intrinsic LehmerCodeToPermutation(lehmer::SeqEnum) -> GrpPermElt
  {Returns permutation corresponding to Lehmer code.}
  n := #lehmer;
  lehmer := [el + 1 : el in lehmer];
  p_seq := [];
  open_spots := [1..n];
  for j in lehmer do
    Append(~p_seq, open_spots[j]);
    Remove(~open_spots,j);
  end for;
  return Sym(n)!p_seq;
end intrinsic;

// We encode groups using strings that allow for their reconstruction
// Moved from IO.m so that it could be used while just attaching hashspec

function is_iterative_description(desc)
    for i in [1..#desc - 1] do
        if desc[i] eq "-" and not desc[i+1] in "123456789" then
            return true;
        end if;
    end for;
    return false;
end function;

sporadic_codes := AssociativeArray();
sporadic_codes["J1"] := "7,11Mat010000000100000001000000010000000100000001100000082AA8A89113133AA8A882A8A882A8A882AA13391133391131";
sporadic_codes["J2"] := "6,q4Mat111100000000101100000000101011110000011010110000001111110001111011001100011011101111011001101001010111111000000000001010111011110111111011011101";
sporadic_codes["HS"] := "Simp138";
sporadic_codes["J3"] := "18,q9Mat201000000000000000000000000000000000000010000000000000000000000000000000202010000000000000000000000000000000000000001000000000000000000000000000000000000000100000000000000000000000000000000000001000000000000000000000000000100000000000000000000000000000000000000000000000001000000000000000000000000000000000000010000000000000000000000000000000000000100000000000000000000010000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000001000112120022120100222211111101000000200202102102201012202121021020010102200000000000000000010000000000000000000000000000000000000100000000000000000101102022111100102022110220000211210001000000000000000000000000000000000100000000000000000000000000000000000000000100000000000000000000000000000000010000000000000000000000000000000000000000010000000000000000000000000000000001000000000000000000000000000000000000000000010000000000000000000000000000000000000100000000000000000000000000000100000000000000000000000000000000000001000000000000000000000000000000000000000000000001000000000000000000000000000000000000010000000122120102010010202011100102200000000000000000000000000001000000000000000000000000000000000000010000000000000000000000000000000000000000000000010201022112010002000102002001001011002000000000000000000000000000000100000";
sporadic_codes["McL"] := "Simp269";
sporadic_codes["He"] := "51,2Mat001000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000001000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000100100111011011000101011010000011001011111010000001000000000000000000000000000000000000000000000000000010001111111001010111010111010111011110010001001001100101001011110000110001011000101011001100111101100110100110101001000000001100101101101100000011101110110001010110011101011000110111100101110111111001000000010101110111000000010001111011011001011100010001000001101000001111011111111110101111101010010111110100000000000000000000000000000000000000000000000000001001100110111011100101000000111101001010010001001000010011111010010011111111111110110111011100011001100101001110111001100000011010011101101000000100011001111101101100000010101100011111010111011010101101011100000110110110010000100010000011010110010011011111010100000110011111010010100111111100011111110000101100101010010011111100110000101110101111111011100101011111110000100010110110100010001111010100010010110110110011000010101000001110000000011000100100000000100001011100001001111011011001100000110101111110011010000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000100000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000001000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000010000000000000000000000000100000000000000000000000000000010101111001000111111001100010000010000111001000000000000000000000000000010000000000000000000000000000110111010010011110111001001010100010000100000010000000000000000000000000000000000000001000000000000000000000000000000000000000100000000000000000000000000000101101110101101001110011000110100010100000010000010000110011111010000011010000001110101111001000000000000000000000000000000001000000000000000000000000010000010101100100101000010101101010100100000010000000000000000000000000000000100000000000000000000000011110111000110010111101010111100110000011000101110110101101100111001111110110010010100100000010000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000100000000000000000000100000110011111000000000010001001010100111000001000101011011110100101001100101100100110100111101101010000111110110011100101110100100110100100001000010010001011101111000000110100101011101100000001101101111";
sporadic_codes["Ru"] := "28,2Mat11000001100010000000100010100001100001000011100110001010101100000011100110111111010111100011011110000001000010101111011010101000001011001100110010011000111111100110010010000100000000111111100000111101010010000111110010101111000101101110010110100111111011111011110001011111011000000100000100101111100001010100011001001010001010011110101100110110010001110111001010101100110111111100110000111010110011001010101111011000000101100010101010111101011000100111010100111110011111000110001010110110010100011010010000001001001100011010010010001101100011000101001101111000101101000101001000111010111110000100111011110010011010100110010111010001101101100001001000110100111100001110000110011101111010011111010110100000101011101110001111001111100001000101010101000000111000011011101011110110111111101100110111110001010100100101010001101011011110101011000000010011110101001000110011000001010100101110111100110110100011000010000101111001001000000100100101001110011100011100011110000010100001100010100001001000001010010101100110000101111111000010110000110011001100110001011010010110000101011110001100110110100011100011011111101000100011111110110011111011000000011110100100111110001010001010010110011000101000100110000010111101101101110001100100101000011101111001101001100100010001010010100011000111000001100000001100000000101110100011000111101101011010111101011110000100111011110011101100001000111100110000000101000011100011110111110101011001001101100100010001110100001010011010111010110000111001111110010110111000011001011001000000110010100011010010101100010011011111110110000001101110";
sporadic_codes["Co3"] := "22,2Mat10001001101001110110110010011000111110101011000100011100010110001000011111101110101011011010000011011011010100110000001000111111100110010011011011010010001110000000001000010001101000000001111001001110000010100011011110000110110111101010100001100111000011100101001101111100100101100000001010001010011100001000011010010010101101101101011101110101011001011101100110001000100110100010010011001000101110001000101000011010110100011010011011011100110010100010010111111001011001001000011000110101010100000001000001110110001000001010011011101000001100101001001100011100010110011000111010110111011111111011110110110001110010001100001110001111101101111010000111001010011011000001001111111011011011100011110000000100100000101001000011010010111100001100111101101111100011010010100100011111101111101101001110100110001110011100000001110010000011101000110010010101111010000100011101110000101110001111100110110100101001101110010001101101100100001000001111101001101110010100011100011100";
sporadic_codes["Co2"] := "22,2Mat01000000000000000000001000000000000000000000000100000000000000000000100000000000000000000000001000000000000000000000001000000000000000001000000000000000000000111110000000000000000001000000000000000011000100110000000000000000000000100000000000000010100001000000000000001110100010000000000000000000000000100000110010100000001000000000000000000000000001000000000000000100000000000010100000000101010000001010000001011011000000000000000001000000001101001000010010001011000100100001001000010010000000000000000000011000000000000000000000001000000000000000000000010000000000000000000000010000000000000000000000010000000000000000000000100000000000101010010000000000000000000000000100000000000000000000001000000000000000000000010000000000000000000000100000000000000000000001000000000000000000000001000000000000000000000010000001000000000000000000000000000000000000001000010110011011010100000001010011011011001000000111111100110101111000000000000000000000011111110111111111110110";
sporadic_codes["Co1"] := "24,2Mat111101000111000010000110110110010011011100000111000101100001000000101101111110010110010010000110110000100010010111001110100100101010001001100011001011001101011010011111000110011001110111010111000011100110110111110110001011110010011110010100001000000101010001101001110110000101001111001000001000110000100001000110101011011000110001010100010110011111100111011101110111100001001101000010101101100110011110000011111100000110011101001010110100111010000010000111101100101101010000111111010010101010000001000100011100100100001110010100100110101100010110101000101001000010101000100011011001001011001001111011010010011110110010100001010111101000000010101111110001101110100101110100010101101100110001110110101111010000001000001101101110001011101001111010001010000011101010000001010100111100000101110101110000000100010111111001101001011001101001010110101001111110110010101011110001100111010000101000100101111011101111010111100101110110001000101000110111110100000111010011000111100010000111011001100010011110100111101100010010101110011101010111000010110000001010010001001101111000000100101001110111111100000110100110010101110011101101011101010001000000110111111101";

function HexToInteger(s)
    return StringToInteger(s, 16);
end function;
function HexToSignedInteger(s)
    if HexToInteger(s[1]) gt 7 then
        return HexToInteger(s) - 16^#s;
    else
        return HexToInteger(s);
    end if;
end function;

function IntegerToHex(n, b)
    n := Integers()!n;
    if n lt 0 then
        n +:= 16^b;
    end if;
    assert n lt 16^b;
    s := Sprintf("%h", n);
    s := s[3..#s]; // strip leading 0x
    return "0"^(b-#s) * s;
end function;

intrinsic StringToGroup(s::MonStgElt) -> Grp
{}
    // We want to support iterated constructions separated by hyphens, but also need to handle negative signs
    if is_iterative_description(s) then
        path := Split(s, "-");
        G := StringToGroup(path[1]);
        for zig in path[2..#path] do
            if zig[1] eq "A" then
                // Since computing the automorphism group can be expensive, we allow storage of the actual automorphisms
                if #zig eq 1 then
                    G := AutomorphismGroup(G);
                else
                    gens, auts := Explode(Split(zig[2..#zig], ";"));
                    gens := [StringToInteger(c) : c in Split(gens, ",")];
                    auts := [StringToInteger(c) : c in Split(auts, ",")];
                    auts := [auts[i..i+#gens-1] : i in [1..#auts by #gens]];
                    if Type(G) eq GrpPerm then
                        n := Degree(G);
                        gens := [DecodePerm(gen, n) : gen in gens];
                        auts := [[DecodePerm(x, n) : x in imgs] : imgs in auts];
                    elif Type(G) eq GrpMat then
                        d := Dimension(G);
                        R := CoefficientRing(G);
                        if Type(R) eq FldFin and Degree(R) gt 1 then
                            k := Degree(R);
                            gens := [R!gens[i..i+k-1] : i in [1..#gens by k]];
                            auts := [[R!imgs[i..i+k-1] : i in [1..#imgs by k]] : imgs in auts];
                        end if;
                        gens := [G!gens[i..i+d^2-1] : i in [1..#gens by d^2]];
                        auts := [[G!imgs[i..i+d^2-1] : i in [1..#imgs by d^2]] : imgs in auts];
                    elif Type(G) eq GrpPC then
                        n := NumberOfPCGenerators(G);
                        gens := [G!gens[i..i+n-1] : i in [1..#gens by n]];
                        auts := [[G!imgs[i..i+n-1] : i in [1..#imgs by n]] : imgs in auts];
                    else
                        error "Unsupported group type", Type(G);
                    end if;
                    G := AutomorphismGroup(G, gens, auts);
                end if;
            elif zig eq "Z" then
                G := Center(G);
            elif zig eq "D" then
                G := DerivedSubgroup(G);
            elif zig eq "P" then
                G := FrattiniSubgroup(G);
            elif zig eq "F" then
                G := FittingSubgroup(G);
            elif zig eq "R" then
                G := Radical(G);
            elif zig eq "S" then
                G := Socle(G);
            else
                // may want to add quotients here
                error "Unrecognized group construction term", zig;
            end if;
        end for;
        return G;
    elif "Simp" in s then
        N := StringToInteger(s[5..#s]);
        return SimpleGroup(N);
    elif "Perf" in s then
        N := StringToInteger(s[5..#s]);
        return PermutationGroup(PerfectGroupDatabase(), N);
    elif "Chev" in s then
        series, n, q := Explode(Split(s[5..#s], ","));
        n := StringToInteger(n);
        q := StringToInteger(q);
        return ChevalleyGroup(series, n, q);
    elif "Mat" in s then
        dR, L := Explode(Split(s, "Mat"));
        d, Rcode := Explode(Split(dR, ","));
        d := StringToInteger(d);
        b := 1;
        if Rcode eq "0" then
            R := Integers();
            b := #L div d^2;
        elif Rcode[1] eq "q" then
            q := StringToInteger(Rcode[2..#Rcode]);
            _, p := IsPrimePower(q);
            b := 1 + Ilog(16, p-1);
            R := GF(q);
        else
            N := StringToInteger(Rcode);
            b := 1 + Ilog(16, N-1);
            R := Integers(N);
        end if;
        if "," in L then
            L := [StringToInteger(c) : c in Split(L, ",")];
        else
            assert IsDivisibleBy(#L, d^2);
            if Rcode eq "0" then
                L := [HexToSignedInteger(L[i..i+b-1]) : i in [1..#L by b]];
            else
                L := [HexToInteger(L[i..i+b-1]) : i in [1..#L by b]];
            end if;
        end if;
        assert IsDivisibleBy(#L, d^2);
        if Rcode[1] eq "q" then
            k := Degree(R);
            L := [R!L[i..i+k-1] : i in [1..#L by k]];
        end if;
        L := [L[i..i+d^2-1] : i in [1..#L by d^2]];
        return MatrixGroup<d, R| L >;
    elif "Perm" in s then
        n, L := Explode(Split(s, "Perm"));
        n := StringToInteger(n);
        L := [DecodePerm(StringToInteger(c), n) : c in Split(L, ",")];
        return PermutationGroup<n | L>;
    elif "PC" in s then
        N, code := Explode([StringToInteger(c) : c in Split(s, "PC")]);
        return SmallGroupDecoding(code, N);
    elif s[#s] eq ")" and #Split(s, "(") eq 2 then
        // We just use the Magma command to store classical matrix groups, since we can then recover
        // the homomorphism in the projective case
        // We don't just eval in case this code is ever used with untrusted input
        cmd, data := Explode(Split(s[1..#s-1], "("));
        n, q := Explode([StringToInteger(c) : c in Split(data, ",")]);
        assert cmd in ["GL", "SL", "Sp", "SO", "SOPlus", "SOMinus", "SU", "GO", "GOPlus", "GOMinus", "GU", "CSp", "CSO", "CSOPlus", "CSOMinus", "CSU", "CO", "COPlus", "COMinus", "CU", "Omega", "OmegaPlus", "OmegaMinus", "Spin", "SpinPlus", "SpinMinus", "PGL", "PSL", "PSp", "PSO", "PSOPlus", "PSOMinus", "PSU", "PGO", "PGOPlus", "PGOMinus", "PGU", "POmega", "POmegaPlus", "POmegaMinus", "PGammaL", "PSigmaL", "PSigmaSp", "PGammaU", "AGL", "ASL", "ASp", "AGammaL", "ASigmaL", "ASigmaSp"];
        cmd := eval cmd;
        return cmd(n, q);
    elif s in ["J1", "J2", "HS", "J3", "McL", "He", "Ru", "Co3", "Co2", "Co1"] then
        return StringToGroup(sporadic_codes[s]);
    elif "." in s then
        N, i := Explode([StringToInteger(c) : c in Split(s, ".")]);
        return SmallGroup(N, i);
    elif "T" in s then
        n, t := Explode([StringToInteger(c) : c in Split(s, "T")]);
        return TransitiveGroup(n, t);
    else
        error "Unrecognized format", s;
    end if;
end intrinsic;
